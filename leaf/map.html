<!DOCTYPE html>
<html>
<head>
	<title></title>
	<link rel="stylesheet" href="./leaflet.css"/>
	<script src="./leaflet.js"></script>
	<script src="./polyline.encoded.min.js"></script>
	<script src="./leaflet-vectorgrid.js"></script>
	<script src="./polyline.snake.min.js"></script>
	<script src="./rides_edited.js"></script>
	<style>
		body {
			margin: 0;
			overflow: hidden;
		}
		#map {
			height: 100vh;
		}
		a {
			cursor: pointer;
		}
	</style>
</head>
<body>
	<div id="map"></div>

	<script type="text/javascript">
		var map = L.map('map').setView([37.7706, -122.4482]);

		map.setZoom(12.5);
		map.setMaxBounds([[[37.296, -121.809],[38.125, -122.986]]]);
		L.control.scale().addTo(map);
		// var vectorStyles = {
		// 	aeroway: {fill: false, weight: 0},
		// 	boundary: {fill: false, weight: 0},
		// 	building: {fill: false, weight: 0},
		// 	housenumber: {fill: false, weight: 0},
		// 	landcover: {fill: false, weight: 0},
		// 	landuse: {fill: false, weight: 0},
		// 	park: {fill: false, weight: 0},
		// 	place: {fill: false, weight: 0},
		// 	poi: {fill: false, weight: 0},
		// 	transportation: {fill: true, weight: 1},
		// 	transportation_name: {fill: false, weight: 0},
		// 	water: {	// Apply these options to the "water" layer...
		// 		fill: true,
		// 		weight: 1,
		// 		fillColor: '#06cccc',
		// 		color: '#06cccc',
		// 		fillOpacity: 0.2,
		// 		opacity: 0.4,
		// 	},
		// 	water_name: {fill: false, weight: 0},
		// 	waterway: {fill: false, weight: 0},
		// }

		// var openMapTilesUrl = "https://api.maptiler.com/tiles/v3/{z}/{x}/{y}.pbf?key=H0g8Wcmg7yUGheWBJpg0";
		// var openMapTilesLayer = L.vectorGrid.protobuf(openMapTilesUrl, {
		// 	rendererFactory: L.canvas.tile,
		// 	vectorTileLayerStyles: vectorStyles,
		// 	subdomains: '0123',
		// 	maxZoom: 14,
		// 	minZoom: 10,
		// 	attribution: '© OpenStreetMap contributors, © MapTiler',
		// 	key: 'H0g8Wcmg7yUGheWBJpg0' // Get yours at https://maptiler.com/cloud/
		// });
		// openMapTilesLayer.addTo(map);
		var Stamen_TonerLite = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}{r}.{ext}', {
		attribution: 'Tiles - <a href="http://stamen.com">Stamen</a> | Data - <a href="https://www.openstreetmap.org">OSM</a>',
		subdomains: 'abcd',
		minZoom: 10,
		maxZoom: 14.5,
		ext: 'png'
		}).addTo(map);
		// L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
		// 	attribution: 'Tiles - <a href="http://stamen.com">Stamen</a> | Data - <a href="https://www.openstreetmap.org">OSM</a>',
		// 	// subdomains: 'abcd',
		// 	maxZoom: 14.5,
		// 	minZoom: 10,
		// 	ext: 'png'
		// }).addTo(map);

		
		// Stadia_AlidadeSmoothDark.addTo(map);
		// Leaflet.DoubleRightClickZoom google it

		function randomHex() {
			// return `rgb(127,102,152)`
			// return '#000';
			return `#${Math.floor(Math.random()*16777215).toString(16)}`;
		}

		var paths = [];
		function all(limit) {
			clearPaths()
			var count = 0;
			for (var rideID of Object.keys(allRides)) {
				if (count >= limit) return;
				drawPolyLine(rideID);
				count++;
			}
		}
		function clearPaths() {
			paths.forEach(p => {
				p.obj.remove(map);
			})
			paths = [];
		}

		function opt(id = null) {
			return {
				color: randomHex(),
				weight: 2, 
				opacity: .7,
				// smoothFactor: 3,
				id: id,
			}
		}

		function drawPolyLine(path, snake = false, delay = 0) {
			// var options = opt(fixPath[path.toString()] != undefined || allRides[path.toString()] != undefined ? path : null)
			var options = opt(path)
			var p = L.Polyline.fromEncoded(allRides[path.toString()], options);
			p.addEventListener('click', poopUP)
			// p.addEventListener('mouseover', hooveOn)
			// p.addEventListener('mouseout', hooveOff)
			if (snake) {

				setTimeout(() => {p.addTo(map).snakeIn()}, delay);
			} 
			if (!snake) p.addTo(map);
			paths.push({id:path, obj: p});
			return p;
		}

		var popup = L.popup()
		function poopUP(e) {
			popup.setLatLng(e.latlng);
			popup.setContent(`${this.options.id} | <a target="_blank" href="https://www.strava.com/activities/${this.options.id}">Strava</a> | <a target="_blank" onclick="decodeToString(${this.options.id})">Decode</a>`);
			popup.openOn(map);
		}

		function hooveOn(e) {
			Object.keys(paths).forEach(p => {
				if (paths[p].id !== this.options.id) {
					paths[p].obj.setStyle({
						opacity: 0
						// className: 'path hide'
					});
				}
			});
		}
		function hooveOff(e) {
			Object.keys(paths).forEach(p => {
				paths[p].obj.setStyle({
					opacity: 'unset'
					// className: 'path'
				});
			});
		}
		function selectColor(number) {
			const hue = Math.floor(Math.random() * 999) * 137.508; // use golden angle approximation
			return `hsl(${hue},50%,75%)`;
		}

		function decodeToString(polyID, precision = 5){
			var s = "";
			L.PolylineUtil.decode(allRides[polyID], precision).forEach(c => {
				s += '['+ c[0] +', '+ c[1] + '],\n';
				// s += "new google.maps.LatLng(" + c[0] +', '+ c[1] + '),\n';
			})
			console.log("var cords = [\n" + s + "];");
			return s;
		}

		function scoop(rideID) {
			clearPaths()
			var l = drawPolyLine(rideID, true, 1000);
			var p = L.Polyline.fromEncoded(allRides[rideID]);
			// p.addTo(map);
			map.flyToBounds(p.getBounds(), {noMoveStart: true});
		}

		function snake() {
			clearPaths()
			var s = [2652196789,2625229591,2426844362,2018902020,1501518501];
			s.forEach((s, i) => {
				setTimeout(() => {
					drawPolyLine(s, true);
				}, i/2 * 0);
			});
		}
		function path(s) {
			drawPolyLine(s, false)
		}
		// var currentRide = 0;
		// var currentPath;
		// var nextRideID;
		// function start(startKey) {
		// 	if (currentPath != undefined) currentPath.remove(map);
		// 	var key = startKey == undefined ? 0 : Object.keys(allRides).indexOf(startKey.toString());
		// 	nextRideID = key + 1;
		// 	console.log(startKey, key, nextRideID)
		// 	currentRide = Object.keys(allRides)[key];
		// 	currentPath = drawPolyLine(allRides[currentRide], true, opt(currentRide, selectColor(), 4));
		// 	return "Drawing " + currentRide;
		// }
		// var fromIrving = [];
		// var toIrving = [];
		// function save(reverse = false) {
		// 	if (!reverse) fromIrving.push(currentRide);
		// 	if (reverse) toIrving.push(currentRide);
		// 	return "Saved " + currentRide;
		// }
		// function next() {
		// 	currentPath.remove(map);
		// 	currentRide = Object.keys(allRides)[nextRideID]
		// 	currentPath = drawPolyLine(allRides[currentRide], true, opt);
		// 	nextRideID ++;
		// 	return "Drawing " +currentRide;
		// }
		// function prev() {
		// 	currentPath.remove(map);
		// 	currentRide = Object.keys(allRides)[nextRideID - 2]
		// 	currentPath = drawPolyLine(allRides[currentRide], true, opt);
		// 	nextRideID --;
		// 	return "Drawing " +currentRide;
		// }
	</script>
</body>
</html>